# Контекст проекта: Vibe Coding Wheel (MVP)

## 1. Цель
Создать внутреннее веб-приложение для сотрудников, которое в игровой форме выдаёт идею для самостоятельного приложения (“вайб-кодинг”).

Приложение используется в обучающих целях. Архитектура должна быть простой и понятной.

---

## 2. Пользовательский сценарий

1. Пользователь открывает приложение.
2. Вводит свои ФИО (без подтверждения, просто идентификатор).
3. Выбирает уровень подготовки:
   - «У меня есть опыт в программировании»
   - «У меня нет опыта в программировании»
4. Выбирает один из двух путей:
   - **Случайная тема** (через “колесо”)
   - **Своя тема** (ввод текста + проверка)

---

## 3. Взаимоисключающие пути (важно)

Пользователь должен выбрать **ровно один** сценарий, и после выбора второй становится недоступен:

- Если пользователь получил тему через **Случайная тема** → он **уже не может** предложить “свою тему”.
- Если пользователь пошёл по сценарию **Своя тема** (ввёл и подтвердил) → он **уже не может** крутить “колесо”.

Это правило нужно обеспечить на уровне backend (валидация) и UI (скрыть/заблокировать альтернативную кнопку).

---

## 4. Ограничения и правила

- Один пользователь = один финальный выбор темы.
- После финализации темы:
  - тема фиксируется,
  - повторный выбор невозможен,
  - запускается таймер на 14 дней.
- При повторном заходе пользователь видит:
  - свою тему,
  - сколько дней осталось,
  - текст “Good Luck, Have Fun!”.

---

## 5. LLM (GigaChat): генерация и проверка тем (обязательно)

### 5.1 Случайная тема
Если пользователь выбирает сценарий **Случайная тема**, то тема должна **генерироваться через GigaChat** по системному промту.

- Различия тем для “с опытом/без опыта” задаются **в системном промте**, не хардкодятся в приложении.
- Приложение получает от GigaChat темы в структурированном виде (формат задаётся отдельно в промте).
- Для MVP допустимо сделать:
  - генерацию одной темы по запросу пользователя,
  - или генерацию небольшого списка и выбор случайной на сервере.

### 5.2 Своя тема
Если пользователь выбирает сценарий **Своя тема**, то:
- пользователь вводит текст идеи,
- backend отправляет идею в GigaChat,
- GigaChat оценивает достаточную сложность по системному промту.

Результат:
- Если подходит: ответ должен явно содержать фразу **«Тема подходит»** + краткие подсказки с чего начать.
- Если не подходит: GigaChat должен предложить 3–5 вариантов **докрученной** темы до требуемого уровня.

---

## 6. Хранение данных (MVP)

Использовать максимально простое хранение:

- Файл `data/state.json`
- Без баз данных и ORM.

Храним для пользователя:
- fio
- level
- flow: `"random"` или `"own"`
- topic (финальная закреплённая тема)
- chosenAt
- deadlineAt
- (опционально) originalIdea (если пользователь вводил свою)

---

## 7. Backend (Этап 1 — ВАЖНО)

Backend реализуется через Next.js API routes.

Нужно реализовать API:

- POST `/api/login`
  - вход по ФИО + уровень

- POST `/api/spin`
  - запускает сценарий **random**
  - генерирует тему через GigaChat (или через временную mock-реализацию, но с тем же контрактом)
  - фиксирует результат и дедлайн
  - **после этого блокирует сценарий own**

- POST `/api/idea`
  - запускает сценарий **own**
  - проверяет/докручивает тему через GigaChat (или временную mock-реализацию, но с тем же контрактом)
  - если “Тема подходит” → фиксирует тему и дедлайн
  - если “не подходит” → возвращает варианты докрутки, НЕ фиксируя тему
  - **после фиксации блокирует сценарий random**

- GET `/api/me`
  - возвращает текущее состояние пользователя: тема/статус/оставшиеся дни/дедлайн

(Опционально для админки)
- GET `/api/admin/users`
  - список пользователей и их статусы (доступ только по allowlist)

На Этапе 1:
- **НЕ делать UI**
- **НЕ трогать страницы**
- **Сначала API и storage**
- На старте допускается mock GigaChat, но интерфейсы должны быть готовы для замены на реальный вызов.

---

## 8. Frontend (Этап 2)

После готовности backend:

- экран ввода ФИО + выбор уровня,
- выбор пути: случайная тема или своя тема,
- экран “колеса” (случайная тема),
- экран ввода своей идеи,
- экран “тема закреплена” (тема + осталось дней + “Good Luck, Have Fun!”).

UI делается аккуратно, но без расширения функционала.

---

## 9. Общие требования к разработке

- Работать строго по этапам.
- Писать код по файлам, а не “всё сразу”.
- Не предлагать альтернативные стеки.
- Всегда соблюдать правило взаимоисключающих путей (random vs own).

## 10. Админ-кабинет (обязательно до UI-полировки)

Нужна страница админа для просмотра (только read-only):
- список пользователей (fio)
- уровень (level)
- выбранный сценарий (flow: random/own)
- финальная тема (topic)
- дата выбора (chosenAt)
- дедлайн (deadlineAt)
- осталось дней (computed)

Доступ:
- allowlist админов задаётся через ENV (например ADMIN_ALLOWLIST="Иван Иванов;Петр Петров")
- если fio не в allowlist — 403

API:
- GET /api/admin/users?fio=... (или через заголовок, но для MVP можно query)
UI:
- /admin (просмотр таблицы пользователей)



## 11. LLM: DeepSeek (заменить mock)

Используем DeepSeek Chat Completions API:
- Base URL: https://api.deepseek.com/chat/completions
- Auth: Authorization: Bearer <DEEPSEEK_API_KEY>

ENV:
- DEEPSEEK_API_KEY
- DEEPSEEK_MODEL (по умолчанию "deepseek-chat")

Требования:
- Вынести вызов LLM в отдельный server-side модуль (например lib/llm/deepseek.ts)
- Сохранить текущий контракт ответов (random topic, own check: “Тема подходит” или варианты докрутки)
- Добавить флаг USE_DEEPSEEK=true/false для переключения mock/real

## Изменение требований: LLM не используется

Живые ответы LLM не нужны. Вместо LLM используются:
1) Два локальных файла со списками тем для random-сценария (разная сложность).
2) Модерация пользовательских идей админом через админ-панель.

## Random-сценарий (темы из файлов, без повторов)

Есть два пула тем:
- `data/topics_easy.json` — более простой уровень реализации
- `data/topics_hard.json` — более сложный уровень реализации (больше этапов, интеграций, неопределённостей)

Требования к темам:
- темы должны быть прикладными бизнес-задачами (продуктовые/операционные кейсы), НЕ “техническими задачами”
- темы в обоих пулах различаются степенью сложности реализации и этапностью
- темы будут добавлены вручную, их не требуется генерировать, необходимо только создать соответствующие файлы
- каждая тема имеет уникальный `id` и `title`, `description`, `acceptance_criteria` (минимум)

Критичное правило:
- если тема выдана пользователю, она помечается как использованная и **не может быть выдана никому другому**
- это правило распространяется на всех пользователей (глобальная уникальность)

Распределение пула:
- в зависимости от `level` пользователя:
  - level=experienced → брать из `topics_hard.json`
  - level=novice → брать из `topics_easy.json`

Подбор темы:
- сервер выбирает случайную тему из НЕиспользованных в соответствующем пуле
- после выбора тема атомарно помечается как использованная и закрепляется за пользователем

Если в пуле закончились темы:
- возвращать понятную ошибку (например 409) и сообщение “Темы закончились, обратитесь к администратору”.

## Own-сценарий: идея пользователя через админ-модерацию

Пользователь может предложить свою идею (текст).
Живой проверки/докрутки нет. Вместо этого:
- идея сохраняется со статусом `pending`
- админ в админ-панели просматривает pending-идеи и принимает решение:
  - Approve: админ фиксирует финальную формулировку темы (может отредактировать текст) и утверждает
  - Reject: админ отклоняет (с комментарием почему/что поправить)

Пользовательский флоу:
- пользователь отправляет идею → видит статус “На модерации”
- после approve → у пользователя фиксируется тема и дедлайн 14 дней
- после reject → у пользователя остаётся возможность отправить новую идею (или исправленную)

## Взаимоисключающие пути

- Если пользователь получил тему через random → он больше не может предлагать свою идею.
- Если пользователь отправил свою идею (own) → он больше не может крутить random.
- Исключение: если админ отклонил идею (reject), пользователь может отправить идею заново (own), но random всё равно недоступен.

## Данные (MVP, state.json)

Хранение остаётся простым: `data/state.json` (атомарная запись).

Нужно хранить:
- users: fio, level, createdAt
- assignments: fio, flow, topicId/topicText, chosenAt, deadlineAt
- usedTopics:
  - easy: [topicId...]
  - hard: [topicId...]
- submissions (own идеи):
  - id, fio, text, status (pending/approved/rejected), adminComment, approvedTopicText, createdAt, updatedAt

## API изменения

Пользовательские:
- POST `/api/login` (как было)
- POST `/api/spin`:
  - выбирает тему из соответствующего файла (easy/hard), учитывает usedTopics
  - фиксирует assignment + дедлайн
- POST `/api/idea`:
  - создаёт submission со статусом pending (если у пользователя нет assignment)
  - возвращает статус pending
- GET `/api/me`:
  - если assignment есть → вернуть тему, дедлайн, daysLeft
  - если submission pending → вернуть статус pending
  - если rejected → вернуть статус rejected + adminComment и возможность отправить снова

Админские:
- GET `/api/admin/users` (как планировали, read-only)
- GET `/api/admin/submissions` — список pending (и опционально rejected/approved)
- POST `/api/admin/submissions/{id}/approve` — утвердить тему (можно с редактированием)
- POST `/api/admin/submissions/{id}/reject` — отклонить + комментарий

Админ-доступ:
- allowlist из ENV `ADMIN_ALLOWLIST` (разделитель `;`)
- проверка только на /api/admin/* и /admin страницах
